---
title: "Multimodally profiling memory T cells from a tuberculosis cohort identifies cell state associations with demographics, environment and disease (GSE158769)"
subtitle: '[Nathan, et al. Nat Immunol  (2021)](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE158769)'
author: "Developed by [Gabriel Hoffman](http://gabrielhoffman.github.io/)"
date: "Run on `r Sys.time()`"
documentclass: article
output: 
  html_document:
  toc: true
  smart: false
---



<!--- 

--->

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  dev = c("png", "pdf"),
  cache = TRUE,
  cache.lazy = FALSE)
```

```{r load.packages, cache=FALSE}
library(GSEABase)
library(SingleCellExperiment)
library(zellkonverter)
library(dreamlet)
library(scater)
library(ggplot2)
library(zenith)
library(scattermore)
library(tidyverse)
library(knitr)
library(qvalue)
library(cowplot)
library(kableExtra)
library(DelayedArray)

# set block size for reading DelayedMatrix in H5AD file
# The default of 1e8 to small and increasing to the block size 
# (i.e. cache size) to 1e9 decrease run time 
# with increased memory usage
setAutoBlockSize(1e9)
```

```{r load.data}
# read H5AD file
path = "/sc/arion/projects/CommonMind/hoffman/scRNAseq_data/Nathan_NatImm_2021/"
file = paste0(path, "/Nathan_NatImm_2021.h5ad")
sce = readH5AD(file, use_hdf5=TRUE)   

# get only single-cell RNA-seq
# rest is CITE-seq p roteins
only_rna = grep("prot", rownames(sce), invert=TRUE)

# create variable that distinguishes cells from the same donor
# but different batches
sce$donor_batch = with(colData(sce), paste(donor, batch))
sce$batch = factor(sce$batch)
sce$season = factor(sce$season)
sce$TB_status = factor(sce$TB_status, c("CONTROL", "CASE"))

# sort cell clusters by name
sce = sce[only_rna,sce$cluster_name != "NA"]
colData(sce) = droplevels(colData(sce))
tab = colData(sce) %>%
  as_tibble %>%
  group_by(cluster_ids, cluster_name) %>%
  filter(row_number()==1) %>%
  summarise(cluster_ids, cluster_name) %>%
  arrange(as.numeric(gsub("C-", '', cluster_ids)))

sce$cluster_name = factor(sce$cluster_name, unique(tab$cluster_name))
sce$cluster_ids = factor(sce$cluster_ids, unique(tab$cluster_ids))

# create pseudobulk 
pb <- aggregateToPseudoBulk(sce,
    assay = "counts",     
    cluster_id = "cluster_name",  
    sample_id = "donor_batch")
```

```{r UMAP}
colData(sce) %>%
  data.frame %>%
  ggplot(aes(UMAP_1, UMAP_2, color=cluster_name)) +
    geom_scattermore() +
    theme_classic() +
    theme(aspect.ratio=1)
```

```{r cell.ids}
colData(sce) %>%
  as_tibble %>%
  group_by(cluster_ids, cluster_name) %>%
  filter(row_number()==1) %>%
  summarise(cluster_ids, cluster_name) %>%
  arrange(as.numeric(gsub("C-", '', cluster_ids))) %>% 
  kbl(row.names=FALSE) %>% 
  kable_classic(full_width = FALSE) 
```


```{r properties}
# number of batches
nlevels(sce$batch)

# number of donors
nlevels(sce$donor)

# number of donors
df = unique(data.frame(donor = sce$donor, TB_status = sce$TB_status))
table(df$TB_status)
```

```{r cca, fig.height=6, fig.width=6}
form = ~ TB_status + donor + batch + season + prop_NAT
C = canCorPairs(form, colData(pb))

plotCorrMatrix(C)
```


```{r voom}
res.proc = processAssays( pb, ~ TB_status + (1|donor) + (1|batch) + (1|season) + prop_NAT, min.count = 5, 
  min.samples = 10,
  BPPARAM=SnowParam(12, progressbar=TRUE))
```

```{r details}
details(res.proc)
```

```{r plot.voom, fig.width=8, fig.height=16}
plotVoom( res.proc, ncol=4)
```

```{r run.vp}
vp.lst = fitVarPart( res.proc, ~ (1|TB_status) + (1|donor) + (1|batch) + (1|season) + prop_NAT, 
  BPPARAM=SnowParam(12, progressbar=TRUE))
```

```{r plot.vp, fig.width=8, fig.height=16}
plotVarPart(vp.lst, label.angle=60, ncol=4)  
```

```{r summary}
df = vp.lst %>%
  as_tibble %>%
  filter(assay == 'CD4/8+ PD-1+TIGIT+') 

sum(df$batch > 0.10) / length(df$batch)
sum(df$TB_status > 0.01) / length(df$batch)
```

```{r dreamlet}
res.dl = dreamlet( res.proc, ~ TB_status + (1|donor) + (1|batch) + (1|season) + prop_NAT, 
  BPPARAM=SnowParam(12, progressbar=TRUE))
```


```{r volcano, fig.width=9, fig.height=15}
plotVolcano( res.dl, coef = 'TB_statusCASE', ncol=4)
```


### Interpreting variance partitioning analysis
Show that fraction of variation across batches, correlates with GC content

```{r gc.content}
# read GC content
file = paste0(path, '/../misc/GRCh38.104_gc_content.tsv.gz')
df_GC = read.table(file, header=TRUE)

df_vp = merge(as.data.frame(vp.lst), df_GC, by.x="gene", by.y="SYMBOL")

# ggplot(df_vp, aes(batch, GC)) +  
#   geom_scattermore() + 
#   facet_wrap(~assay) +
#   theme_classic() +
#   theme(aspect.ratio=1) +
#   geom_smooth(method = "lm")

# Compute correlation and standard error for Pearson and Spearman
cor.se = function(x,y, method = c("pearson", "kendall", "spearman"),...){

  method = match.arg(method)

  library(tidyverse)
  library(broom)

  if( method == "pearson"){
    df <- cor.test(x,y, method=method,...) %>%
      tidy %>%
      mutate(se = sqrt((1 - estimate^2)/parameter))
    res = data.frame(cor = df$estimate,
      cor.se = df$se)
  }else if(method == "spearman"){
    # https://stats.stackexchange.com/questions/18887/how-to-calculate-a-confidence-interval-for-spearmans-rank-correlation
    rho <- cor(x,y, method=method,...)
    n <- sum(complete.cases(x, y))
    rho.se <- sqrt((1+rho^2/2)/(n-3))

    res <- data.frame(rho = rho,
      rho.se = rho.se)

  }

  return(res) 
}

df_vp %>%
  group_by(assay) %>%
  summarize(cor.se(batch, GC, method="spearman")) %>%
  ggplot(aes(assay, rho)) +
    geom_bar(stat="identity") + 
    geom_errorbar(aes(ymin= rho - 1.96*rho.se, ymax= rho + 1.96*rho.se), width=0) +
    theme_classic() +
    theme(aspect.ratio=1) +
    xlab("Cell type") +
    ylab("Spearman correlation between batch % and GC content") +
    coord_flip() 
```


```{r vp.cpm}
tab = topTable(res.dl, 'TB_statusCASE', number=Inf)

df_vp = merge(as.data.frame(vp.lst), tab, by.x=c("assay", "gene"), by.y=c("assay", "ID") )

df_vp %>%
  as_tibble %>%
  group_by(assay) %>%
  summarize(cor.se(donor, AveExpr, method="spearman")) %>%
  ggplot(aes(assay, rho)) +
    geom_bar(stat="identity") + 
    geom_errorbar(aes(ymin= rho - 1.96*rho.se, ymax= rho + 1.96*rho.se), width=0) +
    theme_classic() +
    theme(aspect.ratio=1) +
    xlab("Cell type") +
    ylab("Spearman correlation between Donor % and CPM") +
    coord_flip() 
```



```{r zenith}
go.gs = get_GeneOntology(to="SYMBOL")

res.zenith = zenith_gsa( res.dl, go.gs, 'TB_statusCASE')
```

```{r plot.zenith, fig.width=15, fig.height=16}
res.zenith$assay = factor(res.zenith$assay, names(res.dl))
plotZenithResults(res.zenith, 3, 1)
```


```{r plot.zenith.subset, fig.width=8, fig.height=2.5}
#GO0002456
idx = grep( "GO0050852|GO0001909|GO0022625|GO0042101", res.zenith$Geneset)
plotZenithResults(res.zenith[idx,], 3, 1, transpose=FALSE) + 
  theme(axis.text.x=element_text(size=10, angle = 90),
    axis.text.y=element_text(size=10), 
    legend.position="right",
    legend.key.size = unit(.3, 'cm') ) 
```


```{r plotPercent}
CT = "CD4/8+ PD-1+TIGIT+"
genes = vp.lst %>%
  as_tibble %>%
  filter(assay == CT) %>%
  summarize(gene[order(batch, decreasing=TRUE)[1:20]],
            gene[order(donor, decreasing=TRUE)[1:20]],
            gene[order(TB_status, decreasing=TRUE)[1:20]],
            gene[order(Residuals, decreasing=TRUE)[1:20]]) %>%
  unlist %>% 
  array

genes = c("MALAT1", 'HIST1H1E', "CXCR4", 'DUSP2', 'LTB', 'HELZ', 'ITGB1', 'PARK7')  

fig.percent = plotPercentBars(vp.lst, assays = CT, genes = genes)
fig.percent
```

# Figure Panels
```{r panels, fig.height=4, fig.width=12}
fig.umap = colData(sce) %>%
  data.frame %>%
  ggplot(aes(UMAP_1, UMAP_2, color=ifelse(cluster_name==CT, CT, ''))) +
    geom_scattermore() +
    theme_classic() +
    scale_color_manual(name='', values=c("grey", "orange")) +
    theme(aspect.ratio=1, axis.text.x=element_blank(), axis.text.y=element_blank(), legend.position="bottom") +
    xlab('UMAP 1') +
    ylab('UMAP 2')

thm = theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), aspect.ratio=1)

fig.voom = plotVoom( res.proc[[CT]] ) + theme_classic() + thm
fig.vp = plotVarPart(vp.lst, assays = CT, label.angle=20) + thm +   theme(axis.text.x=element_text(size=10))
fig.vol = plotVolcano( res.dl[[CT]], coef = 'TB_statusCASE')

fig.pct = fig.percent + theme(aspect.ratio=1, legend.position="bottom")

plot_grid(plotlist = list(fig.umap, fig.voom, fig.vp, fig.pct), nrow=1, labels=LETTERS[1:4], align="hv", axis="t")
```

```{r panels2, fig.height=4}
data = extractData(res.proc, CT)

fig.strat1 = plotStratify( HIST1H1E ~ batch, data, legend=FALSE, colorBy=NULL) + 
  theme(aspect.ratio=1)

fig.strat2 = plotStratify( IAH1 ~ TB_status, data, x.labels=TRUE) +
  theme(aspect.ratio=4, legend.position="none")

plot_grid(fig.strat1, fig.strat2, align="hv", axis="tb", rel_widths=c(1.5,1), labels=LETTERS[5:6])
```

```{r panels3, fig.height=8, fig.width=5}
zmax = 3.5
gs1 = "GO0001909: leukocyte mediated cytotoxicity"
fig.heat1 = plotGeneHeatmap( res.dl, coef="TB_statusCASE", genes=geneIds(go.gs[[gs1]]), assays=CT, zmax=zmax) + 
  ggtitle(gs1) + 
  theme(legend.key.size = unit(.3, 'cm'), 
    axis.text.x=element_text(size=5, angle=90),
    axis.text.y=element_text(size=5))

gs2 = 'GO0002431: Fc receptor mediated stimulatory signaling pathway'
fig.heat2 = plotGeneHeatmap( res.dl, coef="TB_statusCASE", genes=geneIds(go.gs[[gs2]]), assays=CT, zmax=zmax) + 
  ggtitle(gs2) + 
  theme(legend.key.size = unit(.3, 'cm'),
    axis.text.x=element_text(size=5, angle=20),
    axis.text.y=element_text(size=5))

fig.heat1
fig.heat2
```



```{r plot.pi, fig.height=5, fig.width=16}
tab = topTable(res.dl, coef = 'TB_statusCASE', number=Inf) %>%
  as_tibble %>% 
  group_by(assay) %>%
  summarize( nDE = sum(adj.P.Val < 0.05), 
            pi1 = 1 - pi0est(P.Value)$pi0,
            nGenes = length(adj.P.Val)) %>%
  mutate(assay = factor(assay, assayNames(pb)))

fig1 = ggplot(tab, aes(nGenes, assay)) + 
    geom_bar(stat="identity") + 
    theme_classic() +
    theme(aspect.ratio=1) +
    scale_x_continuous(limits=c(0,NA), expand=c(0,10)) +
    xlab("# genes expressed") +
    ylab("Cell type")

fig2 = ggplot(tab, aes(nDE, assay)) + 
    geom_bar(stat="identity") + 
    theme_classic() +
    theme(aspect.ratio=1, axis.text.y=element_blank(), axis.ticks.y = element_blank()) +
    scale_x_continuous(limits=c(0,NA), expand=c(0,10)) +
    xlab("# genes with FDR < 5%") +
    ylab("Cell type")

fig3 = ggplot(tab, aes(pi1, assay)) + 
    geom_bar(stat="identity") + 
    theme_classic() +
    theme(aspect.ratio=1, axis.text.y=element_blank(), axis.ticks.y = element_blank()) +
    scale_x_continuous(limits=c(0,1), expand=c(0,0)) +
    xlab(bquote(pi[1])) +
    ylab("Cell type")

plot_grid(fig1, fig2, fig3, labels=LETTERS[1:3], nrow=1, axis="tblr", align="hv")
```    




# Cell type composition

```{r crumblr}
library(crumblr)

# run crumblr transformation
cobj = crumblr(cellCounts(pb))

# variance partitioning analysis
form = ~ (1|TB_status) + (1|donor) + (1|batch) + (1|season) + prop_NAT
vp_res = fitExtractVarPartModel(cobj, form, colData(pb))
plotVarPart(sortCols(vp_res))

# PCA
E_vst = vst(cobj)
dcmp = prcomp(t(E_vst))

dcmp$x %>%
  merge(colData(pb), by="row.names") %>%
  as.data.frame %>%
  ggplot(aes(PC1, PC2, color=batch)) +
    geom_point() +
    theme_classic() +
    theme(aspect.ratio=1)

# differential abundance analysis
fit = dream(cobj, ~ TB_status + (1|donor) + (1|batch) + (1|season) + prop_NAT, colData(pb))
fit = eBayes(fit)
topTable(fit, coef='TB_statusCASE', number=Inf) %>%   
  kbl() %>% 
  kable_classic(full_width = FALSE) 
```



```{r exit123, cache=FALSE, echo=FALSE}
knitr::knit_exit()
```



Despite the heterogeneity of T-cell expression profiles, we detect as shared component of response to stimulus

## MSigDB
```{r zenith.ms}
go.ms = get_MSigDB(to="SYMBOL")

res.zenith.ms = zenith_gsa( res.dl, go.ms, 'TB_statusCASE')
```

```{r plot.zenith.ms, fig.width=7, fig.height=16}
plotZenithResults(res.zenith.ms, 3, 1)
```




```{r mashr}
res_mash = run_mash(res.dl, coef='TB_statusCASE')
```


Vd1: C-31

```{r plot.TRBC1}
plotForest(res.dl, "CAST", coef='TB_statusCASE') 
```

```{r plot.TRBC1.mashr}
plotForest(res_mash, "CAST") 
```


```{r mashr.downstream}
# how many gene-by-celltype tests are significant
# i.e.  if a gene is significant in 2 celltypes, it is counted twice
table(get_lfsr(res_mash$model) < 0.05, useNA="ifany")

# how many genes are significant in at least one cell type
table( apply(get_lfsr(res_mash$model), 1, min, na.rm=TRUE) < 0.05)

# how many genes are significant in each cell type
apply(get_lfsr(res_mash$model), 2, function(x) sum(x < 0.05, na.rm=TRUE))

df_gs = zenith_gsa(res_mash, go.gs)
```

```{r mashr.heatmap, fig.width=7, fig.height=10}
# Heatmap of results
plotZenithResults(df_gs, 3, 1)
```

```{r mashr.volcano, fig.width=8, fig.height=16}
# volcano plot based on mashr results
# yaxis uses local false sign rate (lfsr)
plotVolcano(res_mash, ncol=4)
```
















